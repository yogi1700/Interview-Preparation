Ques 1 : OOP is a programming paradigm based on the concept of "objects," which are instances of classes. OOP principles aim to mimic real-world entities and relationships. The four main concepts of OOP are:

Encapsulation: Wrapping data (attributes) and methods (functions) that operate on the data within a single unit or class.
Abstraction: Hiding complex implementation details and exposing only necessary parts.
Inheritance: Creating a new class based on an existing class, inheriting its properties and behavior.
Polymorphism: The ability for functions or methods to behave differently based on input or the type of the object calling them.

Example:

#include <iostream>
using namespace std;

class Shape {  // Base class
public:
    virtual void draw() = 0;  // Pure virtual function for polymorphism
};

class Circle : public Shape {  // Derived class inheriting Shape
public:
    void draw() override {  // Polymorphism: Circle defines how to draw itself
        cout << "Drawing Circle" << endl;
    }
};

int main() {
    Shape* shape = new Circle();  // Abstracted shape
    shape->draw();  // Polymorphism: runtime binding to Circle's draw()
    delete shape;
}


Ques 2: Explain Encapsulation with an Example.

Encapsulation is the concept of bundling data and methods that operate on the data within a single unit, such as a class. It hides the internal states of an object from the outside.

Example:

#include <iostream>
using namespace std;

class BankAccount {
private:
    double balance;  // Encapsulated data

public:
    BankAccount(double initialBalance) : balance(initialBalance) {}

    void deposit(double amount) {
        if (amount > 0) balance += amount;
    }

    double getBalance() const { return balance; }
};

int main() {
    BankAccount account(1000.0);
    account.deposit(500);
    cout << "Balance: " << account.getBalance() << endl;
}

Question 3 : What is Inheritance? Explain with Example.
Inheritance allows one class (child or derived class) to inherit attributes and behaviors (methods) from another class (parent or base class).

Example:
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { cout << "Eating..." << endl; }
};

class Dog : public Animal {  // Dog inherits Animal
public:
    void bark() { cout << "Barking..." << endl; }
};

int main() {
    Dog myDog;
    myDog.eat();  // Inherited method
    myDog.bark();
}

Question 4 : Explain Polymorphism with Examples.

Polymorphism allows methods to do different things based on the object type or input. In C++, polymorphism can be achieved through function overloading, operator 
overloading, and virtual functions.

Example (Virtual Functions):
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal Sound" << endl; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Woof Woof" << endl; }
};

int main() {
    Animal* animal = new Dog();  // Polymorphic call
    animal->sound();  // Outputs "Woof Woof" due to runtime binding
    delete animal;
}

Question 5 : What is Abstraction? Explain with Example.

Abstraction in C++ is the concept of exposing only the essential details to the user, while hiding complex details.

Example : 
#include <iostream>
#include <cmath>
using namespace std;

class Circle {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}
    double getArea() const { return M_PI * radius * radius; }  // Abstracted calculation
};

int main() {
    Circle circle(5.0);
    cout << "Area of circle: " << circle.getArea() << endl;
}

Question 6 : What is the difference between a Class and an Object?

Class: Blueprint or template for creating objects. It defines data members and methods.

Object: Instance of a class that can store data and use methods.

Example:
#include <iostream>
using namespace std;

class Car {
public:
    void start() { cout << "Car started" << endl; }
};

int main() {
    Car myCar;  // Object of class Car
    myCar.start();
}
Question 7: Explain Constructor and Destructor in C++.

Constructor: Special member function that initializes an object.
Destructor: Special member function that cleans up when an object is deleted or goes out of scope.

Example:
#include <iostream>
using namespace std;

class Book {
public:
    Book() { cout << "Constructor called" << endl; }
    ~Book() { cout << "Destructor called" << endl; }
};

int main() {
    Book myBook;  // Constructor called here
}  // Destructor called here when myBook goes out of scope


Question 8 : What is Function Overloading in C++?
Function overloading allows multiple functions to have the same name with different parameters.

Example:
#include <iostream>
using namespace std;

class Print {
public:
    void display(int i) { cout << "Integer: " << i << endl; }
    void display(double d) { cout << "Double: " << d << endl; }
};

int main() {
    Print print;
    print.display(5);
    print.display(5.5);
}
Question 9 : What is Operator Overloading?
Operator overloading allows operators to be defined for user-defined types, enabling intuitive expressions with custom objects.

Example:
#include <iostream>
using namespace std;

class Complex {
public:
    int real, imag;

    Complex(int r, int i) : real(r), imag(i) {}

    Complex operator+(const Complex &other) {
        return Complex(real + other.real, imag + other.imag);
    }

    void display() { cout << real << " + " << imag << "i" << endl; }
};

int main() {
    Complex a(1, 2), b(3, 4);
    Complex c = a + b;  // Using overloaded + operator
    c.display();
}

Question 10 : Explain Virtual Functions and Pure Virtual Functions.
Virtual Function: A function in a base class that can be overridden in derived classes, supporting runtime polymorphism.
Pure Virtual Function: A function declared in a base class with no implementation, forcing derived classes to implement it.

#include <iostream>
using namespace std;

class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function
};

class Square : public Shape {
public:
    void draw() override { cout << "Drawing Square" << endl; }
};

int main() {
    Shape* shape = new Square();
    shape->draw();
    delete shape;
}
Question 11: What is the Difference between "new" and "malloc" in C++?
new is an operator that initializes objects and returns a pointer. It also calls the constructor.
malloc is a C library function that allocates memory but does not call the constructor.

#include <iostream>
using namespace std;

class Test {
public:
    Test() { cout << "Constructor called" << endl; }
    ~Test() { cout << "Destructor called" << endl; }
};

int main() {
    Test* obj1 = new Test;  // Calls constructor
    delete obj1;  // Calls destructor

    Test* obj2 = (Test*)malloc(sizeof(Test));  // No constructor
    free(obj2);  // No destructor
}

Question 12: What are Smart Pointers? Explain Unique, Shared, and Weak Pointers.
Smart pointers are template classes in C++ that manage memory automatically to prevent memory leaks. 
Types include:
Unique Pointer (std::unique_ptr): Exclusive ownership; cannot be copied.
Shared Pointer (std::shared_ptr): Shared ownership; maintains a reference count.
Weak Pointer (std::weak_ptr): Refers to an object managed by a shared pointer but does not affect the reference count.

Example:
#include <iostream>
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> uniquePtr = make_unique<int>(10);
    cout << "UniquePtr: " << *uniquePtr << endl;

    shared_ptr<int> sharedPtr = make_shared<int>(20);
    cout << "SharedPtr: " << *sharedPtr << endl;
    
    weak_ptr<int> weakPtr = sharedPtr;  // weak_ptr created from shared_ptr
    cout << "WeakPtr (expired? " << weakPtr.expired() << ")" << endl;
}

Question 13: What is the "this" Pointer in C++?
The this pointer is an implicit pointer available to all non-static member functions. It points to the calling object.
#include <iostream>
using namespace std;

class Demo {
public:
    void showThis() {
        cout << "Address of current object: " << this << endl;
    }
};

int main() {
    Demo d;
    d.showThis();
}

Question 14:  Explain the Use of const Keyword.
The const keyword is used to declare constants. It can be applied to variables, pointers, member functions, and function arguments to prevent modification.

Example:
#include <iostream>
using namespace std;

class MyClass {
public:
    void display() const { cout << "This is a const function" << endl; }
};

int main() {
    const int num = 5;  // constant variable
    MyClass obj;
    obj.display();
}
Question 15 : What is an Inline Function in C++?

Inline functions are functions defined with the inline keyword, suggesting the compiler to replace the function call with the function's code. 
Used to reduce function call overhead.

#include <iostream>
using namespace std;

inline int add(int a, int b) { return a + b; }

int main() {
    cout << "Sum: " << add(3, 4) << endl;
}
Question 16 : Explain Template Functions and Template Classes in C++.

Templates allow the creation of generic functions and classes that work with any data type.

Example : function 

#include <iostream>
using namespace std;

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add<int>(3, 4) << endl;
    cout << add<double>(5.5, 2.2) << endl;
}

Example : Class

#include <iostream>
using namespace std;

template <typename T>
class Calculator {
public:
    T add(T a, T b) { return a + b; }
};

int main() {
    Calculator<int> intCalc;
    cout << intCalc.add(3, 4) << endl;

    Calculator<double> doubleCalc;
    cout << doubleCalc.add(3.5, 4.5) << endl;
}

Question 17 :  What are Friend Functions and Friend Classes?

Friend functions/classes are given access to private and protected members of another class.

#include <iostream>
using namespace std;

class A {
    friend class B;  // B is a friend of A
private:
    int data = 5;
};

class B {
public:
    void show(A &a) { cout << "Data from A: " << a.data << endl; }
};

int main() {
    A a;
    B b;
    b.show(a);
}

Question 18 : What is Function Overriding?

Function overriding occurs in inheritance, where a derived class provides its own implementation of a function declared in its base class.

Example:
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { cout << "Base Show" << endl; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived Show" << endl; }
};

int main() {
    Base* ptr = new Derived();
    ptr->show();
    delete ptr;
}

Question 19 : What is the Role of static Keyword?

static variables in functions retain their value between calls.
static member variables are shared among all objects of a class.
static member functions can be called without creating an instance.

#include <iostream>
using namespace std;

class Counter {
public:
    static int count;  // static variable
    Counter() { count++; }
    static void display() { cout << "Count: " << count << endl; }
};

int Counter::count = 0;

int main() {
    Counter a, b, c;
    Counter::display();
}


Question 20 : What is an Abstract Class?

An abstract class contains at least one pure virtual function and cannot be instantiated.

Example:
#include <iostream>
using namespace std;

class Shape {
public:
    virtual void draw() = 0;  // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override { cout << "Drawing Circle" << endl; }
};

int main() {
    Circle c;
    c.draw();
}

Question 21 : What is Exception Handling? Explain try, catch, and throw.?

Exception handling allows handling runtime errors to prevent program crashes using try, catch, and throw.

#include <iostream>
using namespace std;

int divide(int a, int b) {
    if (b == 0) throw "Division by zero!";
    return a / b;
}

int main() {
    try {
        cout << divide(10, 0) << endl;
    } catch (const char* msg) {
        cerr << "Error: " << msg << endl;
    }
}

Question 22 : What is std::move in C++?

std::move enables moving resources from one object to another without copying, often used in resource management and to enable move semantics.

Example :
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

int main() {
    vector<int> v1 = {1, 2, 3};
    vector<int> v2 = std::move(v1);  // Moves v1's data to v2
    cout << "v1 size: " << v1.size() << endl;
    cout << "v2 size: " << v2.size() << endl;
}

Question 23 : What is the RAII (Resource Acquisition is Initialization) Idiom?

RAII is a C++ idiom where resources are acquired and released within the lifetime of an object, thus avoiding resource leaks.

Example:
#include <iostream>
#include <fstream>
using namespace std;

class FileHandler {
    ifstream file;

public:
    FileHandler(const string& filename) : file(filename) {
        if (!file) throw runtime_error("File not opened");
    }
    ~FileHandler() { file.close(); }  // Automatically closes file
};

int main() {
    try {
        FileHandler handler("example.txt");
    } catch (const exception &e) {
        cerr << e.what() << endl;
    }
}

Question 24: Explain the Difference between Shallow and Deep Copy.
Shallow Copy: Copies only the memory addresses, leading to issues with pointers.
Deep Copy: Duplicates the actual data, ensuring independent copies.

#include <iostream>
#include <cstring>
using namespace std;

class ShallowCopy {
public:
    char* data;
    ShallowCopy(const char* str) { data = strdup(str); }
    ~ShallowCopy() { delete data; }
    // Shallow copy will delete the same memory location
};

class DeepCopy {
public:
    char* data;
    DeepCopy(const char* str) {
       

Question 25 : 


